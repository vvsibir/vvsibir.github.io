<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <title>–ê–Ω–∞–ª–∏–∑ —á–∞—Å—Ç–æ—Ç—ã –∑–≤—É–∫–∞</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> 
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            text-align: center;
        }
        canvas {
            max-width: 100%;
            height: auto;
        }
        #recordButton:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <h1>–ó–∞–ø–∏—Å—å –∏ –∞–Ω–∞–ª–∏–∑ –∑–≤—É–∫–∞</h1>
    <button id="recordButton">–ù–∞—á–∞—Ç—å –∑–∞–ø–∏—Å—å</button>
    <button id="playButton" disabled>‚ñ∂Ô∏è –ü—Ä–æ–∏–≥—Ä–∞—Ç—å</button>
    <audio id="audioPlayback" controls style="display:none;"></audio>
    
    <p id="status">–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –¥–ª—è –Ω–∞—á–∞–ª–∞ –∑–∞–ø–∏—Å–∏</p>
    <canvas id="freqChart" width="800" height="400"></canvas>

    <script>
        const recordButton = document.getElementById('recordButton');
        const statusText = document.getElementById('status');
        const playButton = document.getElementById('playButton');
        let audio = null;
        let audioContext;
        let mediaStream;
        let mediaRecorder;
        let recordedChunks = [];

        // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
        const sampleRate = 11025; // –ß–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏
        
        const recordSeconds = 5; // –≤—Ä–µ–º—è –∑–∞–ø–∏—Å–∏, —Å–µ–∫—É–Ω–¥

        let currentSource = null;

        // –ü—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º, recordedChunks —É–∂–µ –∑–∞–ø–æ–ª–Ω–µ–Ω
        playButton.addEventListener('click', () => {
            if (recordedChunks.length === 0) {
                console.warn("–ù–µ—Ç –∑–∞–ø–∏—Å–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö");
                return;
            }

            // –°–æ–∑–¥–∞—ë–º Blob –∏–∑ recordedChunks
            const superBuffer = new Blob(recordedChunks, { type: 'audio/webm' });

            // –î–ª—è –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–Ω–∏—è —á–µ—Ä–µ–∑ <audio>
            const audioURL = URL.createObjectURL(superBuffer);
            const audioElement = document.getElementById('audioPlayback');
            audioElement.src = audioURL;
            audioElement.play();
            audioElement.style.display = 'block';

            // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞: —á–µ—Ä–µ–∑ Web Audio API (–µ—Å–ª–∏ –Ω—É–∂–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞)
            /*
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            const fileReader = new FileReader();
            fileReader.onload = function() {
                audioContext.decodeAudioData(fileReader.result, function(buffer) {
                    if (currentSource) {
                        currentSource.stop();
                    }
                    currentSource = audioContext.createBufferSource();
                    currentSource.buffer = buffer;
                    currentSource.connect(audioContext.destination);
                    currentSource.start();
                });
            };
            fileReader.readAsArrayBuffer(superBuffer);
            */
        });

        // === –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ WAV –∏–∑ –¥–∞–Ω–Ω—ã—Ö ===
        function floatTo16BitPCM(input) {
            const buffer = new ArrayBuffer(input.length * 2);
            const view = new DataView(buffer);
            for (let i = 0; i < input.length; i++) {
                const s = Math.max(-1, Math.min(1, input[i]));
                const val = s < 0 ? s * 32768 : s * 32767;
                view.setInt16(i * 2, val, true);
            }
            return view;
        }

        function writeWAVBuffer(buffer, sampleRate) {
            const headerSize = 44;
            const wavBuffer = new ArrayBuffer(headerSize + buffer.byteLength);
            const view = new DataView(wavBuffer);

            function writeString(view, offset, str) {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset + i, str.charCodeAt(i));
                }
            }

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + buffer.byteLength, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // PCM
            view.setUint16(22, 1, true); // –ú–æ–Ω–æ
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, buffer.byteLength, true);

            const pcmData = new Uint8Array(buffer);
            for (let i = 0; i < pcmData.length; i++) {
                view.setUint8(44 + i, pcmData[i]);
            }

            return view;
        }

        // === –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞—É–¥–∏–æ –ø–æ—Å–ª–µ –∑–∞–ø–∏—Å–∏ ===
        async function processAudioBuffer(audioBuffer) {
            if (!audioBuffer || audioBuffer.numberOfChannels === 0) {
                console.error("audioBuffer –ø—É—Å—Ç–æ–π!");
                return;
            }

            const sampleRate = audioBuffer.sampleRate;

            // –°–æ–∑–¥–∞—ë–º OfflineAudioContext
            const offlineCtx = new OfflineAudioContext(
                1,                      // 1 –∫–∞–Ω–∞–ª (–º–æ–Ω–æ)
                audioBuffer.length,   // –¥–ª–∏–Ω–∞ –±—É—Ñ–µ—Ä–∞
                sampleRate            // —á–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏
            );

            // –°–æ–∑–¥–∞—ë–º –∏—Å—Ç–æ—á–Ω–∏–∫ –∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –∞—É–¥–∏–æ–±—É—Ñ–µ—Ä–∞
            const source = offlineCtx.createBufferSource();
            source.buffer = audioBuffer;

            // –ü–æ–¥–∫–ª—é—á–∞–µ–º –∫ –≤—ã—Ö–æ–¥—É
            source.connect(offlineCtx.destination);

            // ‚ö†Ô∏è –ó–∞–ø—É—Å–∫–∞–µ–º –∏—Å—Ç–æ—á–Ω–∏–∫ –î–û —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞!
            source.start();

            try {
                // üü¢ –¢–µ–ø–µ—Ä—å –≤—ã–∑—ã–≤–∞–µ–º startRendering()
                const renderedBuffer = await offlineCtx.startRendering();

                // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ
                const rawData = renderedBuffer.getChannelData(0);
                const pcmData = floatTo16BitPCM(rawData);
                const wavBuffer = writeWAVBuffer(pcmData, sampleRate);

                // Base64
                const arrayBuffer = wavBuffer.buffer;
                const blob = new Blob([arrayBuffer], { type: 'audio/wav' });

                const base64WAV = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = error => reject(error);
                    reader.readAsDataURL(blob);
                });

                sendToServer(base64WAV);
            } catch (err) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–µ:', err);
            }
        }
        // === –û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä ===
        async function sendToServer(wavBase64) {
            console.log(wavBase64);
            statusText.textContent = "–û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö...";
            try {
                const response = await fetch("https://functions.yandexcloud.net/d4e44n05pmuailluel6s?integration=raw",  {
                    method: "POST",
                    headers: {
                        //"Content-Type": "application/json"
                        "Content-Length": wavBase64.length
                    },
                    body: wavBase64                    
                });
                const rt = await response.text();
                console.log("result: " + rt);
                var result;
                try {
                    const data = JSON.parse(rt);
                    console.log('–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:', data);
                    result = data;
                } catch (e) {
                    console.error('–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å JSON:', e);
                }

                if (result.statusCode == "200" && result.body && result.body.frequencies && result.body.amplitude) {
                    //console.log("result.body.frequencies: " + result.body.frequencies);
                    //console.log("result.body.amplitude: " + result.body.amplitude);
                    drawChart(result.body.frequencies, result.body.amplitude);
                    statusText.textContent = "–ü–æ–ª—É—á–µ–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç\n" + result;
                } else {
                    statusText.textContent = "–û—à–∏–±–∫–∞: –¥–∞–Ω–Ω—ã–µ –æ —á–∞—Å—Ç–æ—Ç–∞—Ö –Ω–µ –ø–æ–ª—É—á–µ–Ω—ã." + result;
                }
            } catch (error) {
                console.error("–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞:", error);
                statusText.textContent = "–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö.";
            } finally {
                recordButton.disabled = false;
            }
        }

        // === –ì—Ä–∞—Ñ–∏–∫ ===
        function drawChart(frequencies, amplitude) {
            statusText.textContent = "–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞...";
            const ctx = document.getElementById('freqChart').getContext('2d');  
            if (window.freqChartInstance) {
                window.freqChartInstance.destroy();
            }
            // console.log("drawChart frequencies: " + frequencies);
            // console.log("drawChart amplitude: " + amplitude);
            window.freqChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: frequencies,
                    datasets: [{
                        label: '–ê–º–ø–ª–∏—Ç—É–¥–∞',
                        data: amplitude,
                        borderColor: 'rgba(75, 192, 192, 1)',
                        fill: false,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: '–ß–∞—Å—Ç–æ—Ç–∞ (–ì—Ü)' }
                        },
                        y: {
                            title: { display: true, text: '–ê–º–ø–ª–∏—Ç—É–¥–∞' }
                        }
                    }
                }
            });
        }
        // === –ó–∞–ø—É—Å–∫ –∑–∞–ø–∏—Å–∏ –ø–æ—Å–ª–µ –∫–ª–∏–∫–∞ ===
        recordButton.addEventListener('click', async () => {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } else if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            recordButton.disabled = true;
            statusText.textContent = "–ò–¥—ë—Ç –∑–∞–ø–∏—Å—å... –ü–æ–¥–æ–∂–¥–∏—Ç–µ " + recordSeconds + " —Å–µ–∫—É–Ω–¥.";

            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(mediaStream, { mimeType: 'audio/webm' });

                mediaRecorder.ondataavailable = event => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    statusText.textContent = "–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö...";
                    const blob = new Blob(recordedChunks, { type: 'audio/webm' });
                    const reader = new FileReader();
                    reader.onload = () => {
                        const arrayBuffer = reader.result;

                        audioContext.decodeAudioData(arrayBuffer, decodedBuffer => {
                            processAudioBuffer(decodedBuffer);
                        }, err => {
                            console.error("–û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è:", err);
                            statusText.textContent = "–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–≤—É–∫–∞.";
                            recordButton.disabled = false;
                        });
                    };
                    reader.readAsArrayBuffer(blob);
                    playButton.disabled = false;
                };
                mediaRecorder.start();
                setTimeout(() => {
                    mediaRecorder.stop();
                }, recordSeconds * 1000); // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —á–µ—Ä–µ–∑ recordSeconds —Å–µ–∫—É–Ω–¥
            } catch (err) {
                console.error("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É:", err);
                alert("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É.");
                recordButton.disabled = false;
                statusText.textContent = "–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –∑–∞–ø–∏—Å–∏.";
            }
        });
    </script>
</body>
</html>